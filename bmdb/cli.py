from pathlib import Path
import os
import sys
import click
import yaml
from dotenv import load_dotenv
from sqlalchemy import create_engine, inspect

MODELS_FILE = Path.cwd() / "bmdb" / "models" / "models.bmdb"  # Always use absolute path
OUT_DIR = Path.cwd() / "bmdb" / "models" / "generated"  # Always use absolute path

@click.group()
def main():
    """BMDB - minimal schema manager"""
    pass

def load_models():
    """Load models from models.bmdb file in current directory"""
    if not MODELS_FILE.exists():
        return {"models": {}}
    with open(MODELS_FILE, "r", encoding="utf-8") as f:
        return yaml.safe_load(f) or {"models": {}}

def save_models(data):
    """Save models to models.bmdb file in current directory"""
    with open(MODELS_FILE, "w", encoding="utf-8") as f:
        yaml.safe_dump(data, f, sort_keys=False, allow_unicode=True)

def generate_models():
    """Generate Python models from models.bmdb"""
    # First, try to find .env in current directory
    env_path = Path.cwd() / ".env"
    if env_path.exists():
        load_dotenv(dotenv_path=env_path)
    else:
        load_dotenv()  # Try default location
    
    db_url = os.getenv("DB_CONNECTION")
    if not db_url:
        print(f"Error: DB_CONNECTION missing in .env file at {env_path}")
        return

    data = load_models()
    if not data.get("models"):
        print("No models found in models.bmdb")
        return

    # Create output directory
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    
    click.echo(f"Generating models to: {OUT_DIR}")

    # Generate models with CRUD methods
    code = [
        "# -*- coding: utf-8 -*-",
        "# Generated by BMDB - DO NOT EDIT MANUALLY",
        "# " + "="*70,
        "",
        "from sqlalchemy import Column, Integer, String, Text, Float, Boolean, Date, DateTime, ForeignKey, create_engine",
        "from sqlalchemy.orm import declarative_base, sessionmaker, Session",
        "from sqlalchemy.orm import relationship",
        "import os",
        "from dotenv import load_dotenv",
        "from pathlib import Path",
        "",
        "Base = declarative_base()",
        "",
        "# Load DB connection from .env at runtime",
        "# Try to find .env in current directory first",
        "env_path = Path.cwd() / '.env'",
        "if env_path.exists():",
        "    load_dotenv(dotenv_path=env_path)",
        "else:",
        "    load_dotenv()",
        "",
        "DB_URL = os.getenv('DB_CONNECTION', '').strip('\"')",
        "engine = create_engine(DB_URL, echo=False) if DB_URL else None",
        "SessionLocal = sessionmaker(bind=engine) if engine else None",
        "",
        "class ModelMixin:",
        "    '''Mixin to add CRUD methods to models'''",
        "    ",
        "    def save(self):",
        "        '''Create or update this instance'''",
        "        if not SessionLocal:",
        "            raise RuntimeError('Database not configured. Check your .env file')",
        "        session = SessionLocal()",
        "        try:",
        "            session.add(self)",
        "            session.commit()",
        "            session.refresh(self)",
        "            return self",
        "        except Exception as e:",
        "            session.rollback()",
        "            raise e",
        "        finally:",
        "            session.close()",
        "    ",
        "    def delete(self):",
        "        '''Delete this instance'''",
        "        if not SessionLocal:",
        "            raise RuntimeError('Database not configured. Check your .env file')",
        "        session = SessionLocal()",
        "        try:",
        "            session.delete(self)",
        "            session.commit()",
        "            return True",
        "        except Exception as e:",
        "            session.rollback()",
        "            raise e",
        "        finally:",
        "            session.close()",
        "    ",
        "    @classmethod",
        "    def get(cls, id):",
        "        '''Get record by ID'''",
        "        if not SessionLocal:",
        "            raise RuntimeError('Database not configured. Check your .env file')",
        "        session = SessionLocal()",
        "        try:",
        "            return session.query(cls).filter(cls.id == id).first()",
        "        finally:",
        "            session.close()",
        "    ",
        "    @classmethod",
        "    def all(cls):",
        "        '''Get all records'''",
        "        if not SessionLocal:",
        "            raise RuntimeError('Database not configured. Check your .env file')",
        "        session = SessionLocal()",
        "        try:",
        "            return session.query(cls).all()",
        "        finally:",
        "            session.close()",
        "    ",
        "    @classmethod",
        "    def filter(cls, **kwargs):",
        "        '''Filter records by field values'''",
        "        if not SessionLocal:",
        "            raise RuntimeError('Database not configured. Check your .env file')",
        "        session = SessionLocal()",
        "        try:",
        "            query = session.query(cls)",
        "            for key, value in kwargs.items():",
        "                if hasattr(cls, key):",
        "                    query = query.filter(getattr(cls, key) == value)",
        "            return query.all()",
        "        finally:",
        "            session.close()",
        "    ",
        "    @classmethod",
        "    def first(cls, **kwargs):",
        "        '''Get first record matching filters'''",
        "        if not SessionLocal:",
        "            raise RuntimeError('Database not configured. Check your .env file')",
        "        session = SessionLocal()",
        "        try:",
        "            query = session.query(cls)",
        "            for key, value in kwargs.items():",
        "                if hasattr(cls, key):",
        "                    query = query.filter(getattr(cls, key) == value)",
        "            return query.first()",
        "        finally:",
        "            session.close()",
        "    ",
        "    @classmethod",
        "    def count(cls, **kwargs):",
        "        '''Count records matching filters'''",
        "        if not SessionLocal:",
        "            raise RuntimeError('Database not configured. Check your .env file')",
        "        session = SessionLocal()",
        "        try:",
        "            query = session.query(cls)",
        "            for key, value in kwargs.items():",
        "                if hasattr(cls, key):",
        "                    query = query.filter(getattr(cls, key) == value)",
        "            return query.count()",
        "        finally:",
        "            session.close()",
        "    ",
        "    def to_dict(self):",
        "        '''Convert model instance to dictionary'''",
        "        result = {}",
        "        for column in self.__table__.columns:",
        "            result[column.name] = getattr(self, column.name)",
        "        return result",
        "",
    ]

    type_map = {
        "String": "String",
        "Text": "Text",
        "Int": "Integer",
        "Integer": "Integer",
        "Float": "Float",
        "Boolean": "Boolean",
        "Date": "Date",
        "DateTime": "DateTime",
        "JSON": "JSON"
    }

    # Generate model classes
    for m_name, m_data in data["models"].items():
        code.append(f"class {m_name}(Base, ModelMixin):")
        code.append(f'    __tablename__ = "{m_name.lower()}s"')
        code.append("    id = Column(Integer, primary_key=True, autoincrement=True)")
        for f_name, f_type in m_data.get("fields", {}).items():
            base_type = f_type.split()[0].strip()
            col_type = type_map.get(base_type, "String")
            # Check for unique constraint
            if "@unique" in f_type:
                code.append(f"    {f_name} = Column({col_type}, unique=True)  # {f_type}")
            else:
                code.append(f"    {f_name} = Column({col_type})  # {f_type}")
        code.append("")

    # Write models.py
    models_py_path = OUT_DIR / "models.py"
    models_py_path.write_text("\n".join(code), encoding="utf-8")
    
    # Write __init__.py
    init_py_path = OUT_DIR / "__init__.py"
    init_py_content = '''"""
Generated models package.
"""
from .models import Base, ModelMixin
'''
    init_py_path.write_text(init_py_content, encoding="utf-8")

    # Write migrate.py
    migrate_code = [
        "# -*- coding: utf-8 -*-",
        "# migrate.py - run manually or use bmdb migrate",
        "from .models import Base, engine",
        "",
        "if engine:",
        "    Base.metadata.create_all(engine)",
        "    print('Tables created')",
        "else:",
        "    print('Error: DB_CONNECTION not set')"
    ]
    (OUT_DIR / "migrate.py").write_text("\n".join(migrate_code), encoding="utf-8")

    click.echo(f"‚úì Generated models to: {OUT_DIR}")
    click.echo(f"‚úì Main models file: {models_py_path}")

@main.command("create-model")
@click.argument("name")
def create_model(name):
    """Create a new model"""
    data = load_models()
    if name in data["models"]:
        click.echo(f"‚úó Model '{name}' already exists")
        return
    data["models"][name] = {"fields": {}}
    save_models(data)
    click.echo(f"‚úì Model '{name}' created in {MODELS_FILE}")

@main.command("add-fields")
@click.argument("model")
@click.argument("fields", nargs=-1)
@click.option("--unique", multiple=True)
def add_fields(model, fields, unique):
    """Add fields to a model"""
    if len(fields) % 2 != 0:
        click.echo("‚úó Fields must come in name-type pairs (e.g., 'name String age Integer')")
        return
    data = load_models()
    if model not in data["models"]:
        click.echo(f"‚úó Model '{model}' not found. Create it first with 'bmdb create-model {model}'")
        return
    uniques = set(unique)
    for i in range(0, len(fields), 2):
        fname = fields[i]
        ftype = fields[i+1]
        defn = ftype + (" @unique" if fname in uniques else "")
        data["models"][model]["fields"][fname] = defn
    save_models(data)
    click.echo(f"‚úì Fields added to model '{model}'")
    click.echo(f"  Updated {MODELS_FILE}")

@main.command("generate")
def generate():
    """Generate Python models from models.bmdb"""
    click.echo(f"Current directory: {Path.cwd()}")
    click.echo(f"Looking for models.bmdb at: {MODELS_FILE}")
    generate_models()

@main.command("migrate")
def migrate():
    """Create database tables from generated models"""
    try:
        # Load .env from current directory
        env_path = Path.cwd() / ".env"
        if env_path.exists():
            load_dotenv(dotenv_path=env_path)
            click.echo(f"‚úì Loaded .env from: {env_path}")
        else:
            load_dotenv()
            click.echo("‚ö† Using default .env location")
        
        db_url = os.getenv("DB_CONNECTION", "").strip('"')
        if not db_url:
            click.echo("‚úó Error: DB_CONNECTION not found in .env")
            click.echo(f"  Check your .env file at: {env_path}")
            return
        
        click.echo(f"‚úì DB URL loaded: {db_url[:50]}...")
        
        # Look for models in current directory
        models_path = OUT_DIR / "models.py"
        click.echo(f"Looking for models at: {models_path}")
        
        if not models_path.exists():
            click.echo(f"‚úó Error: Generated models not found at {models_path}")
            click.echo("  Make sure you're in the project root and ran 'bmdb generate'")
            click.echo(f"  Current directory: {Path.cwd()}")
            return
        
        # Clear import cache
        for module in list(sys.modules.keys()):
            if 'bmdb' in module or 'generated' in module:
                del sys.modules[module]
        
        # Add current directory to Python path
        sys.path.insert(0, str(Path.cwd()))
        
        click.echo("‚úì Importing models...")
        
        # Dynamic import
        import importlib.util
        spec = importlib.util.spec_from_file_location("generated_models", str(models_path))
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        
        Base = module.Base
        click.echo(f"‚úì Successfully imported Base with {len(Base.metadata.tables)} table(s)")
        
        # Show tables to be created
        for table_name in Base.metadata.tables.keys():
            click.echo(f"  - {table_name}")
        
        click.echo("‚úì Creating engine...")
        engine = create_engine(db_url, echo=True)
        
        # Check existing tables
        inspector = inspect(engine)
        existing_tables = inspector.get_table_names()
        click.echo(f"‚úì Existing tables in database: {existing_tables}")
        
        click.echo("‚úì Creating tables...")
        Base.metadata.create_all(engine)
        
        # Verify
        new_tables = inspector.get_table_names()
        click.echo(f"‚úì All tables now: {new_tables}")
        
        # Show newly created tables
        created = set(new_tables) - set(existing_tables)
        if created:
            click.echo(f"‚úÖ New tables created: {list(created)}")
        else:
            click.echo("‚ö† Note: No new tables were created (they might already exist)")
        
        click.echo("‚úÖ Migration completed!")
        
    except Exception as e:
        click.echo(f"‚úó Migration failed: {type(e).__name__}: {e}")
        import traceback
        traceback.print_exc()

@main.command("list-models")
def list_models():
    """List all defined models"""
    data = load_models()
    if not data.get("models"):
        click.echo("No models defined in models.bmdb")
        return
    
    click.echo(f"Models defined in {MODELS_FILE}:")
    click.echo("=" * 50)
    for model_name, model_data in data["models"].items():
        click.echo(f"\nüìã {model_name}:")
        fields = model_data.get("fields", {})
        if fields:
            for field_name, field_type in fields.items():
                click.echo(f"  ‚îú‚îÄ {field_name}: {field_type}")
        else:
            click.echo("  ‚îî‚îÄ (no fields defined yet)")

@main.command("init")
def init():
    """Initialize a new BMDB project"""
    current_dir = Path.cwd()
    click.echo(f"Initializing BMDB project in: {current_dir}")
    
    # Create models.bmdb if not exists
    if MODELS_FILE.exists():
        click.echo(f"‚úì {MODELS_FILE} already exists")
    else:
        save_models({"models": {}})
        click.echo(f"‚úì Created {MODELS_FILE}")
    
    # Create .env.example if not exists
    env_example = current_dir / ".env.example"
    if not env_example.exists():
        with open(env_example, "w") as f:
            f.write("# Database connection\n")
            f.write("# Copy this file to .env and edit with your credentials\n")
            f.write("DB_CONNECTION=postgresql://username:password@localhost:5432/database_name\n")
            f.write("\n# SQLite example:\n")
            f.write("# DB_CONNECTION=sqlite:///database.db\n")
        click.echo(f"‚úì Created {env_example}")
    
    # Create project structure
    project_structure = [
        current_dir / "bmdb",
        current_dir / "bmdb" / "models",
        current_dir / "bmdb" / "models" / "generated",
    ]
    
    for folder in project_structure:
        folder.mkdir(parents=True, exist_ok=True)
    
    click.echo("‚úì Created project structure")
    
    click.echo("\n" + "="*50)
    click.echo("‚úÖ Project initialized successfully!")
    click.echo("\nNext steps:")
    click.echo("1. Copy .env.example to .env and edit with your database details")
    click.echo("2. Create your first model: bmdb create-model User")
    click.echo("3. Add fields: bmdb add-fields User name String email String --unique email")
    click.echo("4. Generate models: bmdb generate")
    click.echo("5. Migrate database: bmdb migrate")
    click.echo("\nFor help: bmdb --help")

@main.command("where")
def where():
    """Show current paths and locations"""
    click.echo("üìÅ Current paths:")
    click.echo(f"  Current directory: {Path.cwd()}")
    click.echo(f"  MODELS_FILE: {MODELS_FILE}")
    click.echo(f"  OUT_DIR: {OUT_DIR}")
    click.echo(f"  Python executable: {sys.executable}")
    click.echo(f"  Python path: {sys.path[:3]}")

if __name__ == "__main__":
    main()